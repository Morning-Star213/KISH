import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  DateTime: { input: any; output: any; }
  File: { input: any; output: any; }
};

export type Brand = {
  __typename?: 'Brand';
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  imageUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
};

export type Category = {
  __typename?: 'Category';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type Color = {
  __typename?: 'Color';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type Condition = {
  __typename?: 'Condition';
  comment?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  resaleRate?: Maybe<Scalars['Int']['output']>;
  tradeInRate?: Maybe<Scalars['Int']['output']>;
  uuid: Scalars['ID']['output'];
};

export type ConditionAttributes = {
  name?: InputMaybe<Scalars['String']['input']>;
  resaleRate?: InputMaybe<Scalars['Int']['input']>;
  tradeInRate?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of CreateCondition */
export type CreateConditionInput = {
  attributes: ConditionAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateCondition. */
export type CreateConditionPayload = {
  __typename?: 'CreateConditionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  condition?: Maybe<Condition>;
  error?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateListingImage */
export type CreateListingImageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file?: InputMaybe<Scalars['File']['input']>;
  uuid: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateListingImage. */
export type CreateListingImagePayload = {
  __typename?: 'CreateListingImagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  listing?: Maybe<Listing>;
};

/** Autogenerated input type of CreateListing */
export type CreateListingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uuid: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateListing. */
export type CreateListingPayload = {
  __typename?: 'CreateListingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  listing?: Maybe<Listing>;
};

/** Autogenerated input type of CreateProductImage */
export type CreateProductImageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file?: InputMaybe<Scalars['File']['input']>;
  uuid: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateProductImage. */
export type CreateProductImagePayload = {
  __typename?: 'CreateProductImagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  product?: Maybe<Product>;
};

/** Autogenerated input type of CreateProduct */
export type CreateProductInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  product: ProductAttributes;
  productMaster: ProductMasterAttributes;
};

/** Autogenerated return type of CreateProduct. */
export type CreateProductPayload = {
  __typename?: 'CreateProductPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  product?: Maybe<Product>;
};

export type Image = {
  __typename?: 'Image';
  id: Scalars['ID']['output'];
  image: Scalars['String']['output'];
  imageUrl: Scalars['String']['output'];
  resourceId?: Maybe<Scalars['ID']['output']>;
  resourceType?: Maybe<Scalars['String']['output']>;
};

export type Item = {
  __typename?: 'Item';
  id: Scalars['ID']['output'];
  listing: Listing;
  listingId: Scalars['ID']['output'];
  orderId: Scalars['ID']['output'];
  price?: Maybe<Scalars['Int']['output']>;
  uuid: Scalars['ID']['output'];
};

export type Listing = {
  __typename?: 'Listing';
  brandId: Scalars['ID']['output'];
  comment?: Maybe<Scalars['String']['output']>;
  conditionId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  images?: Maybe<Array<Image>>;
  organizationId: Scalars['ID']['output'];
  price?: Maybe<Scalars['Int']['output']>;
  product: Product;
  productId: Scalars['ID']['output'];
  repairMethod?: Maybe<Scalars['String']['output']>;
  repairMethodI18n?: Maybe<Scalars['String']['output']>;
  sellerId: Scalars['ID']['output'];
  size?: Maybe<Size>;
  sizeId?: Maybe<Scalars['ID']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  statusI18n?: Maybe<Scalars['String']['output']>;
  uuid: Scalars['ID']['output'];
};

export type ListingAttributes = {
  comment?: InputMaybe<Scalars['String']['input']>;
  conditionId?: InputMaybe<Scalars['ID']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  repairMethod?: InputMaybe<Scalars['String']['input']>;
  sellerId?: InputMaybe<Scalars['ID']['input']>;
  sizeId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type ListingSearch = {
  keyword?: InputMaybe<Scalars['String']['input']>;
};

export type Listings = {
  __typename?: 'Listings';
  listings: Array<Listing>;
  pagination: Pagination;
};

export type Mutation = {
  __typename?: 'Mutation';
  createCondition: CreateConditionPayload;
  createListing: CreateListingPayload;
  createListingImage: CreateListingImagePayload;
  createProduct: CreateProductPayload;
  createProductImage: CreateProductImagePayload;
  signin: SigninPayload;
  signout: SignoutPayload;
  /** An example field added by the generator */
  testField: Scalars['String']['output'];
  updateCondition: UpdateConditionPayload;
  updateListing: UpdateListingPayload;
  updateListingImage: UpdateListingImagePayload;
  updateProduct: UpdateProductPayload;
  updateProductImage: UpdateProductImagePayload;
  updateProductMaster: UpdateProductMasterPayload;
};


export type MutationCreateConditionArgs = {
  input: CreateConditionInput;
};


export type MutationCreateListingArgs = {
  input: CreateListingInput;
};


export type MutationCreateListingImageArgs = {
  input: CreateListingImageInput;
};


export type MutationCreateProductArgs = {
  input: CreateProductInput;
};


export type MutationCreateProductImageArgs = {
  input: CreateProductImageInput;
};


export type MutationSigninArgs = {
  input: SigninInput;
};


export type MutationSignoutArgs = {
  input: SignoutInput;
};


export type MutationUpdateConditionArgs = {
  input: UpdateConditionInput;
};


export type MutationUpdateListingArgs = {
  input: UpdateListingInput;
};


export type MutationUpdateListingImageArgs = {
  input: UpdateListingImageInput;
};


export type MutationUpdateProductArgs = {
  input: UpdateProductInput;
};


export type MutationUpdateProductImageArgs = {
  input: UpdateProductImageInput;
};


export type MutationUpdateProductMasterArgs = {
  input: UpdateProductMasterInput;
};

export type Order = {
  __typename?: 'Order';
  brandId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<Item>>;
  orderDate?: Maybe<Scalars['DateTime']['output']>;
  orderNumber?: Maybe<Scalars['Int']['output']>;
  paymentStatus?: Maybe<Scalars['String']['output']>;
  paymentStatusI18n?: Maybe<Scalars['String']['output']>;
  shippingStatus?: Maybe<Scalars['String']['output']>;
  shippingStatusI18n?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  statusI18n?: Maybe<Scalars['String']['output']>;
  strageLocation?: Maybe<Scalars['String']['output']>;
  totalPrice?: Maybe<Scalars['Int']['output']>;
  trackingCode?: Maybe<Scalars['String']['output']>;
  uuid: Scalars['ID']['output'];
};

export type OrderSearch = {
  keyword?: InputMaybe<Scalars['String']['input']>;
};

export type Orders = {
  __typename?: 'Orders';
  orders: Array<Order>;
  pagination: Pagination;
};

export type Organization = {
  __typename?: 'Organization';
  brands: Array<Brand>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  sellers: Array<Seller>;
};

export type Pagination = {
  __typename?: 'Pagination';
  currentCount: Scalars['Int']['output'];
  currentPage: Scalars['Int']['output'];
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  nextPage?: Maybe<Scalars['Int']['output']>;
  previousPage?: Maybe<Scalars['Int']['output']>;
  resultsCount: Scalars['Int']['output'];
  totalCount: Scalars['Int']['output'];
  totalPages: Scalars['Int']['output'];
};

export type Product = {
  __typename?: 'Product';
  color?: Maybe<Color>;
  colorId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  images?: Maybe<Array<Image>>;
  isArchive: Scalars['Boolean']['output'];
  isResale: Scalars['Boolean']['output'];
  productMaster: ProductMaster;
  productMasterId?: Maybe<Scalars['ID']['output']>;
  status: Scalars['String']['output'];
  uuid: Scalars['ID']['output'];
};

export type ProductAttributes = {
  brandId?: InputMaybe<Scalars['ID']['input']>;
  colorId?: InputMaybe<Scalars['ID']['input']>;
  isArchive?: InputMaybe<Scalars['Boolean']['input']>;
  isResale?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type ProductMaster = {
  __typename?: 'ProductMaster';
  brandId: Scalars['ID']['output'];
  care?: Maybe<Scalars['String']['output']>;
  categories?: Maybe<Array<Category>>;
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  price?: Maybe<Scalars['Int']['output']>;
  priceTotal?: Maybe<Scalars['Int']['output']>;
  sex?: Maybe<Scalars['String']['output']>;
  sexI18n?: Maybe<Scalars['String']['output']>;
  sizes?: Maybe<Array<Size>>;
  uuid: Scalars['ID']['output'];
  year?: Maybe<Scalars['String']['output']>;
};

export type ProductMasterAttributes = {
  brandId?: InputMaybe<Scalars['ID']['input']>;
  care?: InputMaybe<Scalars['String']['input']>;
  categoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price?: InputMaybe<Scalars['Int']['input']>;
  priceTotal?: InputMaybe<Scalars['Int']['input']>;
  sex?: InputMaybe<Scalars['String']['input']>;
  sizeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  year?: InputMaybe<Scalars['String']['input']>;
};

export type ProductSearch = {
  isArchive?: InputMaybe<Scalars['String']['input']>;
  isResale?: InputMaybe<Scalars['String']['input']>;
  keyword?: InputMaybe<Scalars['String']['input']>;
};

export type Products = {
  __typename?: 'Products';
  pagination: Pagination;
  products: Array<Product>;
};

export type Query = {
  __typename?: 'Query';
  categories: Array<Category>;
  colors: Array<Color>;
  condition: Condition;
  conditions: Array<Condition>;
  currentUser?: Maybe<User>;
  listing: Listing;
  listings: Listings;
  order: Order;
  orders: Orders;
  product: Product;
  productMaster: ProductMaster;
  products: Products;
  sizes: Array<Size>;
  /** An example field added by the generator */
  testField: Scalars['String']['output'];
  user?: Maybe<User>;
};


export type QueryCategoriesArgs = {
  brandId: Scalars['ID']['input'];
};


export type QueryColorsArgs = {
  brandId: Scalars['ID']['input'];
};


export type QueryConditionArgs = {
  uuid: Scalars['ID']['input'];
};


export type QueryConditionsArgs = {
  brandId: Scalars['ID']['input'];
};


export type QueryListingArgs = {
  uuid: Scalars['ID']['input'];
};


export type QueryListingsArgs = {
  brandId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<ListingSearch>;
};


export type QueryOrderArgs = {
  uuid: Scalars['ID']['input'];
};


export type QueryOrdersArgs = {
  brandId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<OrderSearch>;
};


export type QueryProductArgs = {
  uuid: Scalars['ID']['input'];
};


export type QueryProductMasterArgs = {
  brandId: Scalars['ID']['input'];
  code: Scalars['String']['input'];
};


export type QueryProductsArgs = {
  brandId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<ProductSearch>;
};


export type QuerySizesArgs = {
  brandId: Scalars['ID']['input'];
};


export type QueryUserArgs = {
  id: Scalars['ID']['input'];
};

export type Seller = {
  __typename?: 'Seller';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  uuid: Scalars['ID']['output'];
};

/** Autogenerated input type of Signin */
export type SigninInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

/** Autogenerated return type of Signin. */
export type SigninPayload = {
  __typename?: 'SigninPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of Signout */
export type SignoutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of Signout. */
export type SignoutPayload = {
  __typename?: 'SignoutPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  result?: Maybe<Scalars['String']['output']>;
};

export type Size = {
  __typename?: 'Size';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** Autogenerated input type of UpdateCondition */
export type UpdateConditionInput = {
  attributes: ConditionAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uuid: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateCondition. */
export type UpdateConditionPayload = {
  __typename?: 'UpdateConditionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  condition?: Maybe<Condition>;
  error?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateListingImage */
export type UpdateListingImageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file?: InputMaybe<Scalars['File']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateListingImage. */
export type UpdateListingImagePayload = {
  __typename?: 'UpdateListingImagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  listing?: Maybe<Listing>;
};

/** Autogenerated input type of UpdateListing */
export type UpdateListingInput = {
  attributes: ListingAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uuid: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateListing. */
export type UpdateListingPayload = {
  __typename?: 'UpdateListingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  listing?: Maybe<Listing>;
};

/** Autogenerated input type of UpdateProductImage */
export type UpdateProductImageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  file?: InputMaybe<Scalars['File']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProductImage. */
export type UpdateProductImagePayload = {
  __typename?: 'UpdateProductImagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  product?: Maybe<Product>;
};

/** Autogenerated input type of UpdateProduct */
export type UpdateProductInput = {
  attributes: ProductAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uuid: Scalars['ID']['input'];
};

/** Autogenerated input type of UpdateProductMaster */
export type UpdateProductMasterInput = {
  attributes: ProductMasterAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uuid: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProductMaster. */
export type UpdateProductMasterPayload = {
  __typename?: 'UpdateProductMasterPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  productMaster: ProductMaster;
};

/** Autogenerated return type of UpdateProduct. */
export type UpdateProductPayload = {
  __typename?: 'UpdateProductPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  product?: Maybe<Product>;
};

export type User = {
  __typename?: 'User';
  confirmationToken?: Maybe<Scalars['String']['output']>;
  email: Scalars['String']['output'];
  firstName?: Maybe<Scalars['String']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  organization?: Maybe<Organization>;
  organizationId?: Maybe<Scalars['ID']['output']>;
  role: Scalars['String']['output'];
  roleI18n?: Maybe<Scalars['String']['output']>;
};

export type BrandFragmentFragment = { __typename?: 'Brand', id: string, name: string };

export type CategoryFragmentFragment = { __typename?: 'Category', id: string, name: string };

export type ColorFragmentFragment = { __typename?: 'Color', id: string, name: string };

export type ConditionFragmentFragment = { __typename?: 'Condition', id: string, uuid: string, name?: string | null, tradeInRate?: number | null, resaleRate?: number | null };

export type ImageFragmentFragment = { __typename?: 'Image', id: string, resourceId?: string | null, resourceType?: string | null, image: string, imageUrl: string };

export type ItemFragmentFragment = { __typename?: 'Item', id: string, uuid: string, orderId: string, listingId: string, price?: number | null };

export type ListingFragmentFragment = { __typename?: 'Listing', id: string, uuid: string, organizationId: string, brandId: string, sellerId: string, productId: string, conditionId?: string | null, sizeId?: string | null, status?: string | null, statusI18n?: string | null, repairMethod?: string | null, repairMethodI18n?: string | null, comment?: string | null, price?: number | null };

export type OrderFragmentFragment = { __typename?: 'Order', id: string, uuid: string, brandId: string, orderNumber?: number | null, orderDate?: any | null, totalPrice?: number | null, status?: string | null, statusI18n?: string | null, paymentStatus?: string | null, paymentStatusI18n?: string | null, shippingStatus?: string | null, shippingStatusI18n?: string | null };

export type OrganizationFragmentFragment = { __typename?: 'Organization', id: string, name: string };

export type PaginationFragmentFragment = { __typename?: 'Pagination', resultsCount: number, totalCount: number, totalPages: number, currentPage: number, currentCount: number, nextPage?: number | null, previousPage?: number | null, hasNextPage: boolean, hasPreviousPage: boolean };

export type ProductFragmentFragment = { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null };

export type ProductMasterFragmentFragment = { __typename?: 'ProductMaster', id: string, uuid: string, brandId: string, name: string, code: string, description?: string | null, price?: number | null, priceTotal?: number | null, care?: string | null, sex?: string | null, sexI18n?: string | null, year?: string | null };

export type SellerFragmentFragment = { __typename?: 'Seller', id: string, name: string };

export type SizeFragmentFragment = { __typename?: 'Size', id: string, name: string };

export type UserFragmentFragment = { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, confirmationToken?: string | null, fullName?: string | null, organizationId?: string | null };

export type SigninMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type SigninMutation = { __typename?: 'Mutation', signin: { __typename?: 'SigninPayload', error?: string | null, user?: { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, confirmationToken?: string | null, fullName?: string | null, organizationId?: string | null, organization?: { __typename?: 'Organization', id: string, name: string, brands: Array<{ __typename?: 'Brand', id: string, name: string }> } | null } | null } };

export type SignoutMutationVariables = Exact<{ [key: string]: never; }>;


export type SignoutMutation = { __typename?: 'Mutation', signout: { __typename?: 'SignoutPayload', result?: string | null } };

export type CreateConditionMutationVariables = Exact<{
  attributes: ConditionAttributes;
}>;


export type CreateConditionMutation = { __typename?: 'Mutation', createCondition: { __typename?: 'CreateConditionPayload', error?: string | null, condition?: { __typename?: 'Condition', id: string, uuid: string, name?: string | null, tradeInRate?: number | null, resaleRate?: number | null } | null } };

export type UpdateConditionMutationVariables = Exact<{
  uuid: Scalars['ID']['input'];
  attributes: ConditionAttributes;
}>;


export type UpdateConditionMutation = { __typename?: 'Mutation', updateCondition: { __typename?: 'UpdateConditionPayload', error?: string | null, condition?: { __typename?: 'Condition', id: string, uuid: string, name?: string | null, tradeInRate?: number | null, resaleRate?: number | null } | null } };

export type CreateListingImageMutationVariables = Exact<{
  uuid: Scalars['ID']['input'];
  file: Scalars['File']['input'];
}>;


export type CreateListingImageMutation = { __typename?: 'Mutation', createListingImage: { __typename?: 'CreateListingImagePayload', error?: string | null, listing?: { __typename?: 'Listing', id: string, uuid: string, organizationId: string, brandId: string, sellerId: string, productId: string, conditionId?: string | null, sizeId?: string | null, status?: string | null, statusI18n?: string | null, repairMethod?: string | null, repairMethodI18n?: string | null, comment?: string | null, price?: number | null, images?: Array<{ __typename?: 'Image', id: string, resourceId?: string | null, resourceType?: string | null, image: string, imageUrl: string }> | null } | null } };

export type CreateProductImageMutationVariables = Exact<{
  uuid: Scalars['ID']['input'];
  file: Scalars['File']['input'];
}>;


export type CreateProductImageMutation = { __typename?: 'Mutation', createProductImage: { __typename?: 'CreateProductImagePayload', error?: string | null, product?: { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null, images?: Array<{ __typename?: 'Image', id: string, resourceId?: string | null, resourceType?: string | null, image: string, imageUrl: string }> | null } | null } };

export type UpdateListingImageMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  file: Scalars['File']['input'];
}>;


export type UpdateListingImageMutation = { __typename?: 'Mutation', updateListingImage: { __typename?: 'UpdateListingImagePayload', error?: string | null, listing?: { __typename?: 'Listing', id: string, uuid: string, organizationId: string, brandId: string, sellerId: string, productId: string, conditionId?: string | null, sizeId?: string | null, status?: string | null, statusI18n?: string | null, repairMethod?: string | null, repairMethodI18n?: string | null, comment?: string | null, price?: number | null, images?: Array<{ __typename?: 'Image', id: string, resourceId?: string | null, resourceType?: string | null, image: string, imageUrl: string }> | null } | null } };

export type UpdateProductImageMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  file: Scalars['File']['input'];
}>;


export type UpdateProductImageMutation = { __typename?: 'Mutation', updateProductImage: { __typename?: 'UpdateProductImagePayload', error?: string | null, product?: { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null, images?: Array<{ __typename?: 'Image', id: string, resourceId?: string | null, resourceType?: string | null, image: string, imageUrl: string }> | null } | null } };

export type CreateListingMutationVariables = Exact<{
  uuid: Scalars['ID']['input'];
}>;


export type CreateListingMutation = { __typename?: 'Mutation', createListing: { __typename?: 'CreateListingPayload', error?: string | null, listing?: { __typename?: 'Listing', id: string, uuid: string, organizationId: string, brandId: string, sellerId: string, productId: string, conditionId?: string | null, sizeId?: string | null, status?: string | null, statusI18n?: string | null, repairMethod?: string | null, repairMethodI18n?: string | null, comment?: string | null, price?: number | null, product: { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null } } | null } };

export type UpdateListingMutationVariables = Exact<{
  uuid: Scalars['ID']['input'];
  attributes: ListingAttributes;
}>;


export type UpdateListingMutation = { __typename?: 'Mutation', updateListing: { __typename?: 'UpdateListingPayload', error?: string | null, listing?: { __typename?: 'Listing', id: string, uuid: string, organizationId: string, brandId: string, sellerId: string, productId: string, conditionId?: string | null, sizeId?: string | null, status?: string | null, statusI18n?: string | null, repairMethod?: string | null, repairMethodI18n?: string | null, comment?: string | null, price?: number | null } | null } };

export type CreateProductMutationVariables = Exact<{
  productMaster: ProductMasterAttributes;
  product: ProductAttributes;
}>;


export type CreateProductMutation = { __typename?: 'Mutation', createProduct: { __typename?: 'CreateProductPayload', error?: string | null, product?: { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null } | null } };

export type UpdateProductMutationVariables = Exact<{
  uuid: Scalars['ID']['input'];
  attributes: ProductAttributes;
}>;


export type UpdateProductMutation = { __typename?: 'Mutation', updateProduct: { __typename?: 'UpdateProductPayload', error?: string | null, product?: { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null, productMaster: { __typename?: 'ProductMaster', id: string, uuid: string, brandId: string, name: string, code: string, description?: string | null, price?: number | null, priceTotal?: number | null, care?: string | null, sex?: string | null, sexI18n?: string | null, year?: string | null } } | null } };

export type UpdateProductMasterMutationVariables = Exact<{
  uuid: Scalars['ID']['input'];
  attributes: ProductMasterAttributes;
}>;


export type UpdateProductMasterMutation = { __typename?: 'Mutation', updateProductMaster: { __typename?: 'UpdateProductMasterPayload', error?: string | null, productMaster: { __typename?: 'ProductMaster', id: string, uuid: string, brandId: string, name: string, code: string, description?: string | null, price?: number | null, priceTotal?: number | null, care?: string | null, sex?: string | null, sexI18n?: string | null, year?: string | null, sizes?: Array<{ __typename?: 'Size', id: string, name: string }> | null, categories?: Array<{ __typename?: 'Category', id: string, name: string }> | null } } };

export type ConditionQueryVariables = Exact<{
  uuid: Scalars['ID']['input'];
}>;


export type ConditionQuery = { __typename?: 'Query', condition: { __typename?: 'Condition', id: string, uuid: string, name?: string | null, tradeInRate?: number | null, resaleRate?: number | null } };

export type ConditionsQueryVariables = Exact<{
  brandId: Scalars['ID']['input'];
}>;


export type ConditionsQuery = { __typename?: 'Query', conditions: Array<{ __typename?: 'Condition', id: string, uuid: string, name?: string | null, tradeInRate?: number | null, resaleRate?: number | null }> };

export type ListingQueryVariables = Exact<{
  brandId: Scalars['ID']['input'];
  uuid: Scalars['ID']['input'];
}>;


export type ListingQuery = { __typename?: 'Query', listing: { __typename?: 'Listing', id: string, uuid: string, organizationId: string, brandId: string, sellerId: string, productId: string, conditionId?: string | null, sizeId?: string | null, status?: string | null, statusI18n?: string | null, repairMethod?: string | null, repairMethodI18n?: string | null, comment?: string | null, price?: number | null, product: { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null, productMaster: { __typename?: 'ProductMaster', id: string, uuid: string, brandId: string, name: string, code: string, description?: string | null, price?: number | null, priceTotal?: number | null, care?: string | null, sex?: string | null, sexI18n?: string | null, year?: string | null, sizes?: Array<{ __typename?: 'Size', id: string, name: string }> | null, categories?: Array<{ __typename?: 'Category', id: string, name: string }> | null }, color?: { __typename?: 'Color', id: string, name: string } | null, images?: Array<{ __typename?: 'Image', id: string, resourceId?: string | null, resourceType?: string | null, image: string, imageUrl: string }> | null }, size?: { __typename?: 'Size', id: string, name: string } | null, images?: Array<{ __typename?: 'Image', id: string, resourceId?: string | null, resourceType?: string | null, image: string, imageUrl: string }> | null }, conditions: Array<{ __typename?: 'Condition', id: string, uuid: string, name?: string | null, tradeInRate?: number | null, resaleRate?: number | null }> };

export type ListingsQueryVariables = Exact<{
  brandId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<ListingSearch>;
}>;


export type ListingsQuery = { __typename?: 'Query', listings: { __typename?: 'Listings', listings: Array<{ __typename?: 'Listing', id: string, uuid: string, organizationId: string, brandId: string, sellerId: string, productId: string, conditionId?: string | null, sizeId?: string | null, status?: string | null, statusI18n?: string | null, repairMethod?: string | null, repairMethodI18n?: string | null, comment?: string | null, price?: number | null, product: { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null, productMaster: { __typename?: 'ProductMaster', id: string, uuid: string, brandId: string, name: string, code: string, description?: string | null, price?: number | null, priceTotal?: number | null, care?: string | null, sex?: string | null, sexI18n?: string | null, year?: string | null }, color?: { __typename?: 'Color', id: string, name: string } | null } }>, pagination: { __typename?: 'Pagination', resultsCount: number, totalCount: number, totalPages: number, currentPage: number, currentCount: number, nextPage?: number | null, previousPage?: number | null, hasNextPage: boolean, hasPreviousPage: boolean } } };

export type OrdersQueryVariables = Exact<{
  brandId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<OrderSearch>;
}>;


export type OrdersQuery = { __typename?: 'Query', orders: { __typename?: 'Orders', orders: Array<{ __typename?: 'Order', id: string, uuid: string, brandId: string, orderNumber?: number | null, orderDate?: any | null, totalPrice?: number | null, status?: string | null, statusI18n?: string | null, paymentStatus?: string | null, paymentStatusI18n?: string | null, shippingStatus?: string | null, shippingStatusI18n?: string | null }>, pagination: { __typename?: 'Pagination', resultsCount: number, totalCount: number, totalPages: number, currentPage: number, currentCount: number, nextPage?: number | null, previousPage?: number | null, hasNextPage: boolean, hasPreviousPage: boolean } } };

export type ProductQueryVariables = Exact<{
  brandId: Scalars['ID']['input'];
  uuid: Scalars['ID']['input'];
}>;


export type ProductQuery = { __typename?: 'Query', product: { __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null, productMaster: { __typename?: 'ProductMaster', id: string, uuid: string, brandId: string, name: string, code: string, description?: string | null, price?: number | null, priceTotal?: number | null, care?: string | null, sex?: string | null, sexI18n?: string | null, year?: string | null, sizes?: Array<{ __typename?: 'Size', id: string, name: string }> | null, categories?: Array<{ __typename?: 'Category', id: string, name: string }> | null }, images?: Array<{ __typename?: 'Image', id: string, resourceId?: string | null, resourceType?: string | null, image: string, imageUrl: string }> | null }, colors: Array<{ __typename?: 'Color', id: string, name: string }>, sizes: Array<{ __typename?: 'Size', id: string, name: string }>, categories: Array<{ __typename?: 'Category', id: string, name: string }> };

export type ProductMasterQueryVariables = Exact<{
  brandId: Scalars['ID']['input'];
  code: Scalars['String']['input'];
}>;


export type ProductMasterQuery = { __typename?: 'Query', productMaster: { __typename?: 'ProductMaster', id: string, uuid: string, brandId: string, name: string, code: string, description?: string | null, price?: number | null, priceTotal?: number | null, care?: string | null, sex?: string | null, sexI18n?: string | null, year?: string | null } };

export type ProductsQueryVariables = Exact<{
  brandId: Scalars['ID']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<ProductSearch>;
}>;


export type ProductsQuery = { __typename?: 'Query', products: { __typename?: 'Products', products: Array<{ __typename?: 'Product', id: string, uuid: string, status: string, isResale: boolean, isArchive: boolean, colorId?: string | null, productMaster: { __typename?: 'ProductMaster', id: string, uuid: string, brandId: string, name: string, code: string, description?: string | null, price?: number | null, priceTotal?: number | null, care?: string | null, sex?: string | null, sexI18n?: string | null, year?: string | null, categories?: Array<{ __typename?: 'Category', id: string, name: string }> | null }, color?: { __typename?: 'Color', id: string, name: string } | null }>, pagination: { __typename?: 'Pagination', resultsCount: number, totalCount: number, totalPages: number, currentPage: number, currentCount: number, nextPage?: number | null, previousPage?: number | null, hasNextPage: boolean, hasPreviousPage: boolean } } };

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, confirmationToken?: string | null, fullName?: string | null, organizationId?: string | null, organization?: { __typename?: 'Organization', id: string, name: string, brands: Array<{ __typename?: 'Brand', id: string, name: string }>, sellers: Array<{ __typename?: 'Seller', id: string, name: string }> } | null } | null };

export type UserQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type UserQuery = { __typename?: 'Query', user?: { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, confirmationToken?: string | null, fullName?: string | null, organizationId?: string | null } | null };

export const BrandFragmentFragmentDoc = gql`
    fragment brandFragment on Brand {
  id
  name
}
    `;
export const CategoryFragmentFragmentDoc = gql`
    fragment categoryFragment on Category {
  id
  name
}
    `;
export const ColorFragmentFragmentDoc = gql`
    fragment colorFragment on Color {
  id
  name
}
    `;
export const ConditionFragmentFragmentDoc = gql`
    fragment conditionFragment on Condition {
  id
  uuid
  name
  tradeInRate
  resaleRate
}
    `;
export const ImageFragmentFragmentDoc = gql`
    fragment imageFragment on Image {
  id
  resourceId
  resourceType
  image
  imageUrl
}
    `;
export const ItemFragmentFragmentDoc = gql`
    fragment itemFragment on Item {
  id
  uuid
  orderId
  listingId
  price
}
    `;
export const ListingFragmentFragmentDoc = gql`
    fragment listingFragment on Listing {
  id
  uuid
  organizationId
  brandId
  sellerId
  productId
  conditionId
  sizeId
  status
  statusI18n
  repairMethod
  repairMethodI18n
  comment
  price
}
    `;
export const OrderFragmentFragmentDoc = gql`
    fragment orderFragment on Order {
  id
  uuid
  brandId
  orderNumber
  orderDate
  totalPrice
  status
  statusI18n
  paymentStatus
  paymentStatusI18n
  shippingStatus
  shippingStatusI18n
}
    `;
export const OrganizationFragmentFragmentDoc = gql`
    fragment organizationFragment on Organization {
  id
  name
}
    `;
export const PaginationFragmentFragmentDoc = gql`
    fragment paginationFragment on Pagination {
  resultsCount
  totalCount
  totalPages
  currentPage
  currentCount
  nextPage
  previousPage
  hasNextPage
  hasPreviousPage
}
    `;
export const ProductFragmentFragmentDoc = gql`
    fragment productFragment on Product {
  id
  uuid
  status
  isResale
  isArchive
  colorId
}
    `;
export const ProductMasterFragmentFragmentDoc = gql`
    fragment productMasterFragment on ProductMaster {
  id
  uuid
  brandId
  name
  code
  description
  price
  priceTotal
  care
  sex
  sexI18n
  year
}
    `;
export const SellerFragmentFragmentDoc = gql`
    fragment sellerFragment on Seller {
  id
  name
}
    `;
export const SizeFragmentFragmentDoc = gql`
    fragment sizeFragment on Size {
  id
  name
}
    `;
export const UserFragmentFragmentDoc = gql`
    fragment userFragment on User {
  id
  email
  role
  firstName
  lastName
  confirmationToken
  fullName
  organizationId
}
    `;
export const SigninDocument = gql`
    mutation signin($email: String!, $password: String!) {
  signin(input: {email: $email, password: $password}) {
    user {
      ...userFragment
      organization {
        ...organizationFragment
        brands {
          ...brandFragment
        }
      }
    }
    error
  }
}
    ${UserFragmentFragmentDoc}
${OrganizationFragmentFragmentDoc}
${BrandFragmentFragmentDoc}`;
export type SigninMutationFn = Apollo.MutationFunction<SigninMutation, SigninMutationVariables>;

/**
 * __useSigninMutation__
 *
 * To run a mutation, you first call `useSigninMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSigninMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signinMutation, { data, loading, error }] = useSigninMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useSigninMutation(baseOptions?: Apollo.MutationHookOptions<SigninMutation, SigninMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SigninMutation, SigninMutationVariables>(SigninDocument, options);
      }
export type SigninMutationHookResult = ReturnType<typeof useSigninMutation>;
export type SigninMutationResult = Apollo.MutationResult<SigninMutation>;
export type SigninMutationOptions = Apollo.BaseMutationOptions<SigninMutation, SigninMutationVariables>;
export const SignoutDocument = gql`
    mutation signout {
  signout(input: {}) {
    result
  }
}
    `;
export type SignoutMutationFn = Apollo.MutationFunction<SignoutMutation, SignoutMutationVariables>;

/**
 * __useSignoutMutation__
 *
 * To run a mutation, you first call `useSignoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signoutMutation, { data, loading, error }] = useSignoutMutation({
 *   variables: {
 *   },
 * });
 */
export function useSignoutMutation(baseOptions?: Apollo.MutationHookOptions<SignoutMutation, SignoutMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignoutMutation, SignoutMutationVariables>(SignoutDocument, options);
      }
export type SignoutMutationHookResult = ReturnType<typeof useSignoutMutation>;
export type SignoutMutationResult = Apollo.MutationResult<SignoutMutation>;
export type SignoutMutationOptions = Apollo.BaseMutationOptions<SignoutMutation, SignoutMutationVariables>;
export const CreateConditionDocument = gql`
    mutation createCondition($attributes: ConditionAttributes!) {
  createCondition(input: {attributes: $attributes}) {
    condition {
      ...conditionFragment
    }
    error
  }
}
    ${ConditionFragmentFragmentDoc}`;
export type CreateConditionMutationFn = Apollo.MutationFunction<CreateConditionMutation, CreateConditionMutationVariables>;

/**
 * __useCreateConditionMutation__
 *
 * To run a mutation, you first call `useCreateConditionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConditionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConditionMutation, { data, loading, error }] = useCreateConditionMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateConditionMutation(baseOptions?: Apollo.MutationHookOptions<CreateConditionMutation, CreateConditionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConditionMutation, CreateConditionMutationVariables>(CreateConditionDocument, options);
      }
export type CreateConditionMutationHookResult = ReturnType<typeof useCreateConditionMutation>;
export type CreateConditionMutationResult = Apollo.MutationResult<CreateConditionMutation>;
export type CreateConditionMutationOptions = Apollo.BaseMutationOptions<CreateConditionMutation, CreateConditionMutationVariables>;
export const UpdateConditionDocument = gql`
    mutation updateCondition($uuid: ID!, $attributes: ConditionAttributes!) {
  updateCondition(input: {uuid: $uuid, attributes: $attributes}) {
    condition {
      ...conditionFragment
    }
    error
  }
}
    ${ConditionFragmentFragmentDoc}`;
export type UpdateConditionMutationFn = Apollo.MutationFunction<UpdateConditionMutation, UpdateConditionMutationVariables>;

/**
 * __useUpdateConditionMutation__
 *
 * To run a mutation, you first call `useUpdateConditionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConditionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConditionMutation, { data, loading, error }] = useUpdateConditionMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateConditionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConditionMutation, UpdateConditionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateConditionMutation, UpdateConditionMutationVariables>(UpdateConditionDocument, options);
      }
export type UpdateConditionMutationHookResult = ReturnType<typeof useUpdateConditionMutation>;
export type UpdateConditionMutationResult = Apollo.MutationResult<UpdateConditionMutation>;
export type UpdateConditionMutationOptions = Apollo.BaseMutationOptions<UpdateConditionMutation, UpdateConditionMutationVariables>;
export const CreateListingImageDocument = gql`
    mutation createListingImage($uuid: ID!, $file: File!) {
  createListingImage(input: {uuid: $uuid, file: $file}) {
    listing {
      ...listingFragment
      images {
        ...imageFragment
      }
    }
    error
  }
}
    ${ListingFragmentFragmentDoc}
${ImageFragmentFragmentDoc}`;
export type CreateListingImageMutationFn = Apollo.MutationFunction<CreateListingImageMutation, CreateListingImageMutationVariables>;

/**
 * __useCreateListingImageMutation__
 *
 * To run a mutation, you first call `useCreateListingImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateListingImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createListingImageMutation, { data, loading, error }] = useCreateListingImageMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *      file: // value for 'file'
 *   },
 * });
 */
export function useCreateListingImageMutation(baseOptions?: Apollo.MutationHookOptions<CreateListingImageMutation, CreateListingImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateListingImageMutation, CreateListingImageMutationVariables>(CreateListingImageDocument, options);
      }
export type CreateListingImageMutationHookResult = ReturnType<typeof useCreateListingImageMutation>;
export type CreateListingImageMutationResult = Apollo.MutationResult<CreateListingImageMutation>;
export type CreateListingImageMutationOptions = Apollo.BaseMutationOptions<CreateListingImageMutation, CreateListingImageMutationVariables>;
export const CreateProductImageDocument = gql`
    mutation createProductImage($uuid: ID!, $file: File!) {
  createProductImage(input: {uuid: $uuid, file: $file}) {
    product {
      ...productFragment
      images {
        ...imageFragment
      }
    }
    error
  }
}
    ${ProductFragmentFragmentDoc}
${ImageFragmentFragmentDoc}`;
export type CreateProductImageMutationFn = Apollo.MutationFunction<CreateProductImageMutation, CreateProductImageMutationVariables>;

/**
 * __useCreateProductImageMutation__
 *
 * To run a mutation, you first call `useCreateProductImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProductImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProductImageMutation, { data, loading, error }] = useCreateProductImageMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *      file: // value for 'file'
 *   },
 * });
 */
export function useCreateProductImageMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductImageMutation, CreateProductImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProductImageMutation, CreateProductImageMutationVariables>(CreateProductImageDocument, options);
      }
export type CreateProductImageMutationHookResult = ReturnType<typeof useCreateProductImageMutation>;
export type CreateProductImageMutationResult = Apollo.MutationResult<CreateProductImageMutation>;
export type CreateProductImageMutationOptions = Apollo.BaseMutationOptions<CreateProductImageMutation, CreateProductImageMutationVariables>;
export const UpdateListingImageDocument = gql`
    mutation updateListingImage($id: ID!, $file: File!) {
  updateListingImage(input: {id: $id, file: $file}) {
    listing {
      ...listingFragment
      images {
        ...imageFragment
      }
    }
    error
  }
}
    ${ListingFragmentFragmentDoc}
${ImageFragmentFragmentDoc}`;
export type UpdateListingImageMutationFn = Apollo.MutationFunction<UpdateListingImageMutation, UpdateListingImageMutationVariables>;

/**
 * __useUpdateListingImageMutation__
 *
 * To run a mutation, you first call `useUpdateListingImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateListingImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateListingImageMutation, { data, loading, error }] = useUpdateListingImageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      file: // value for 'file'
 *   },
 * });
 */
export function useUpdateListingImageMutation(baseOptions?: Apollo.MutationHookOptions<UpdateListingImageMutation, UpdateListingImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateListingImageMutation, UpdateListingImageMutationVariables>(UpdateListingImageDocument, options);
      }
export type UpdateListingImageMutationHookResult = ReturnType<typeof useUpdateListingImageMutation>;
export type UpdateListingImageMutationResult = Apollo.MutationResult<UpdateListingImageMutation>;
export type UpdateListingImageMutationOptions = Apollo.BaseMutationOptions<UpdateListingImageMutation, UpdateListingImageMutationVariables>;
export const UpdateProductImageDocument = gql`
    mutation updateProductImage($id: ID!, $file: File!) {
  updateProductImage(input: {id: $id, file: $file}) {
    product {
      ...productFragment
      images {
        ...imageFragment
      }
    }
    error
  }
}
    ${ProductFragmentFragmentDoc}
${ImageFragmentFragmentDoc}`;
export type UpdateProductImageMutationFn = Apollo.MutationFunction<UpdateProductImageMutation, UpdateProductImageMutationVariables>;

/**
 * __useUpdateProductImageMutation__
 *
 * To run a mutation, you first call `useUpdateProductImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductImageMutation, { data, loading, error }] = useUpdateProductImageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      file: // value for 'file'
 *   },
 * });
 */
export function useUpdateProductImageMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductImageMutation, UpdateProductImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductImageMutation, UpdateProductImageMutationVariables>(UpdateProductImageDocument, options);
      }
export type UpdateProductImageMutationHookResult = ReturnType<typeof useUpdateProductImageMutation>;
export type UpdateProductImageMutationResult = Apollo.MutationResult<UpdateProductImageMutation>;
export type UpdateProductImageMutationOptions = Apollo.BaseMutationOptions<UpdateProductImageMutation, UpdateProductImageMutationVariables>;
export const CreateListingDocument = gql`
    mutation createListing($uuid: ID!) {
  createListing(input: {uuid: $uuid}) {
    listing {
      ...listingFragment
      product {
        ...productFragment
      }
    }
    error
  }
}
    ${ListingFragmentFragmentDoc}
${ProductFragmentFragmentDoc}`;
export type CreateListingMutationFn = Apollo.MutationFunction<CreateListingMutation, CreateListingMutationVariables>;

/**
 * __useCreateListingMutation__
 *
 * To run a mutation, you first call `useCreateListingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateListingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createListingMutation, { data, loading, error }] = useCreateListingMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *   },
 * });
 */
export function useCreateListingMutation(baseOptions?: Apollo.MutationHookOptions<CreateListingMutation, CreateListingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateListingMutation, CreateListingMutationVariables>(CreateListingDocument, options);
      }
export type CreateListingMutationHookResult = ReturnType<typeof useCreateListingMutation>;
export type CreateListingMutationResult = Apollo.MutationResult<CreateListingMutation>;
export type CreateListingMutationOptions = Apollo.BaseMutationOptions<CreateListingMutation, CreateListingMutationVariables>;
export const UpdateListingDocument = gql`
    mutation updateListing($uuid: ID!, $attributes: ListingAttributes!) {
  updateListing(input: {uuid: $uuid, attributes: $attributes}) {
    listing {
      ...listingFragment
    }
    error
  }
}
    ${ListingFragmentFragmentDoc}`;
export type UpdateListingMutationFn = Apollo.MutationFunction<UpdateListingMutation, UpdateListingMutationVariables>;

/**
 * __useUpdateListingMutation__
 *
 * To run a mutation, you first call `useUpdateListingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateListingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateListingMutation, { data, loading, error }] = useUpdateListingMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateListingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateListingMutation, UpdateListingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateListingMutation, UpdateListingMutationVariables>(UpdateListingDocument, options);
      }
export type UpdateListingMutationHookResult = ReturnType<typeof useUpdateListingMutation>;
export type UpdateListingMutationResult = Apollo.MutationResult<UpdateListingMutation>;
export type UpdateListingMutationOptions = Apollo.BaseMutationOptions<UpdateListingMutation, UpdateListingMutationVariables>;
export const CreateProductDocument = gql`
    mutation createProduct($productMaster: ProductMasterAttributes!, $product: ProductAttributes!) {
  createProduct(input: {productMaster: $productMaster, product: $product}) {
    product {
      ...productFragment
    }
    error
  }
}
    ${ProductFragmentFragmentDoc}`;
export type CreateProductMutationFn = Apollo.MutationFunction<CreateProductMutation, CreateProductMutationVariables>;

/**
 * __useCreateProductMutation__
 *
 * To run a mutation, you first call `useCreateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProductMutation, { data, loading, error }] = useCreateProductMutation({
 *   variables: {
 *      productMaster: // value for 'productMaster'
 *      product: // value for 'product'
 *   },
 * });
 */
export function useCreateProductMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductMutation, CreateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProductMutation, CreateProductMutationVariables>(CreateProductDocument, options);
      }
export type CreateProductMutationHookResult = ReturnType<typeof useCreateProductMutation>;
export type CreateProductMutationResult = Apollo.MutationResult<CreateProductMutation>;
export type CreateProductMutationOptions = Apollo.BaseMutationOptions<CreateProductMutation, CreateProductMutationVariables>;
export const UpdateProductDocument = gql`
    mutation updateProduct($uuid: ID!, $attributes: ProductAttributes!) {
  updateProduct(input: {uuid: $uuid, attributes: $attributes}) {
    product {
      ...productFragment
      productMaster {
        ...productMasterFragment
      }
    }
    error
  }
}
    ${ProductFragmentFragmentDoc}
${ProductMasterFragmentFragmentDoc}`;
export type UpdateProductMutationFn = Apollo.MutationFunction<UpdateProductMutation, UpdateProductMutationVariables>;

/**
 * __useUpdateProductMutation__
 *
 * To run a mutation, you first call `useUpdateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductMutation, { data, loading, error }] = useUpdateProductMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateProductMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductMutation, UpdateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductMutation, UpdateProductMutationVariables>(UpdateProductDocument, options);
      }
export type UpdateProductMutationHookResult = ReturnType<typeof useUpdateProductMutation>;
export type UpdateProductMutationResult = Apollo.MutationResult<UpdateProductMutation>;
export type UpdateProductMutationOptions = Apollo.BaseMutationOptions<UpdateProductMutation, UpdateProductMutationVariables>;
export const UpdateProductMasterDocument = gql`
    mutation updateProductMaster($uuid: ID!, $attributes: ProductMasterAttributes!) {
  updateProductMaster(input: {uuid: $uuid, attributes: $attributes}) {
    productMaster {
      ...productMasterFragment
      sizes {
        ...sizeFragment
      }
      categories {
        ...categoryFragment
      }
    }
    error
  }
}
    ${ProductMasterFragmentFragmentDoc}
${SizeFragmentFragmentDoc}
${CategoryFragmentFragmentDoc}`;
export type UpdateProductMasterMutationFn = Apollo.MutationFunction<UpdateProductMasterMutation, UpdateProductMasterMutationVariables>;

/**
 * __useUpdateProductMasterMutation__
 *
 * To run a mutation, you first call `useUpdateProductMasterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductMasterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductMasterMutation, { data, loading, error }] = useUpdateProductMasterMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateProductMasterMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductMasterMutation, UpdateProductMasterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductMasterMutation, UpdateProductMasterMutationVariables>(UpdateProductMasterDocument, options);
      }
export type UpdateProductMasterMutationHookResult = ReturnType<typeof useUpdateProductMasterMutation>;
export type UpdateProductMasterMutationResult = Apollo.MutationResult<UpdateProductMasterMutation>;
export type UpdateProductMasterMutationOptions = Apollo.BaseMutationOptions<UpdateProductMasterMutation, UpdateProductMasterMutationVariables>;
export const ConditionDocument = gql`
    query condition($uuid: ID!) {
  condition(uuid: $uuid) {
    ...conditionFragment
  }
}
    ${ConditionFragmentFragmentDoc}`;

/**
 * __useConditionQuery__
 *
 * To run a query within a React component, call `useConditionQuery` and pass it any options that fit your needs.
 * When your component renders, `useConditionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConditionQuery({
 *   variables: {
 *      uuid: // value for 'uuid'
 *   },
 * });
 */
export function useConditionQuery(baseOptions: Apollo.QueryHookOptions<ConditionQuery, ConditionQueryVariables> & ({ variables: ConditionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConditionQuery, ConditionQueryVariables>(ConditionDocument, options);
      }
export function useConditionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConditionQuery, ConditionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConditionQuery, ConditionQueryVariables>(ConditionDocument, options);
        }
export function useConditionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ConditionQuery, ConditionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ConditionQuery, ConditionQueryVariables>(ConditionDocument, options);
        }
export type ConditionQueryHookResult = ReturnType<typeof useConditionQuery>;
export type ConditionLazyQueryHookResult = ReturnType<typeof useConditionLazyQuery>;
export type ConditionSuspenseQueryHookResult = ReturnType<typeof useConditionSuspenseQuery>;
export type ConditionQueryResult = Apollo.QueryResult<ConditionQuery, ConditionQueryVariables>;
export const ConditionsDocument = gql`
    query conditions($brandId: ID!) {
  conditions(brandId: $brandId) {
    ...conditionFragment
  }
}
    ${ConditionFragmentFragmentDoc}`;

/**
 * __useConditionsQuery__
 *
 * To run a query within a React component, call `useConditionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConditionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConditionsQuery({
 *   variables: {
 *      brandId: // value for 'brandId'
 *   },
 * });
 */
export function useConditionsQuery(baseOptions: Apollo.QueryHookOptions<ConditionsQuery, ConditionsQueryVariables> & ({ variables: ConditionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConditionsQuery, ConditionsQueryVariables>(ConditionsDocument, options);
      }
export function useConditionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConditionsQuery, ConditionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConditionsQuery, ConditionsQueryVariables>(ConditionsDocument, options);
        }
export function useConditionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ConditionsQuery, ConditionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ConditionsQuery, ConditionsQueryVariables>(ConditionsDocument, options);
        }
export type ConditionsQueryHookResult = ReturnType<typeof useConditionsQuery>;
export type ConditionsLazyQueryHookResult = ReturnType<typeof useConditionsLazyQuery>;
export type ConditionsSuspenseQueryHookResult = ReturnType<typeof useConditionsSuspenseQuery>;
export type ConditionsQueryResult = Apollo.QueryResult<ConditionsQuery, ConditionsQueryVariables>;
export const ListingDocument = gql`
    query listing($brandId: ID!, $uuid: ID!) {
  listing(uuid: $uuid) {
    ...listingFragment
    product {
      ...productFragment
      productMaster {
        ...productMasterFragment
        sizes {
          ...sizeFragment
        }
        categories {
          ...categoryFragment
        }
      }
      color {
        ...colorFragment
      }
      images {
        ...imageFragment
      }
    }
    size {
      ...sizeFragment
    }
    images {
      ...imageFragment
    }
  }
  conditions(brandId: $brandId) {
    ...conditionFragment
  }
}
    ${ListingFragmentFragmentDoc}
${ProductFragmentFragmentDoc}
${ProductMasterFragmentFragmentDoc}
${SizeFragmentFragmentDoc}
${CategoryFragmentFragmentDoc}
${ColorFragmentFragmentDoc}
${ImageFragmentFragmentDoc}
${ConditionFragmentFragmentDoc}`;

/**
 * __useListingQuery__
 *
 * To run a query within a React component, call `useListingQuery` and pass it any options that fit your needs.
 * When your component renders, `useListingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListingQuery({
 *   variables: {
 *      brandId: // value for 'brandId'
 *      uuid: // value for 'uuid'
 *   },
 * });
 */
export function useListingQuery(baseOptions: Apollo.QueryHookOptions<ListingQuery, ListingQueryVariables> & ({ variables: ListingQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListingQuery, ListingQueryVariables>(ListingDocument, options);
      }
export function useListingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListingQuery, ListingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListingQuery, ListingQueryVariables>(ListingDocument, options);
        }
export function useListingSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ListingQuery, ListingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ListingQuery, ListingQueryVariables>(ListingDocument, options);
        }
export type ListingQueryHookResult = ReturnType<typeof useListingQuery>;
export type ListingLazyQueryHookResult = ReturnType<typeof useListingLazyQuery>;
export type ListingSuspenseQueryHookResult = ReturnType<typeof useListingSuspenseQuery>;
export type ListingQueryResult = Apollo.QueryResult<ListingQuery, ListingQueryVariables>;
export const ListingsDocument = gql`
    query listings($brandId: ID!, $page: Int, $perPage: Int, $search: ListingSearch) {
  listings(brandId: $brandId, page: $page, perPage: $perPage, search: $search) {
    listings {
      ...listingFragment
      product {
        ...productFragment
        productMaster {
          ...productMasterFragment
        }
        color {
          ...colorFragment
        }
      }
    }
    pagination {
      ...paginationFragment
    }
  }
}
    ${ListingFragmentFragmentDoc}
${ProductFragmentFragmentDoc}
${ProductMasterFragmentFragmentDoc}
${ColorFragmentFragmentDoc}
${PaginationFragmentFragmentDoc}`;

/**
 * __useListingsQuery__
 *
 * To run a query within a React component, call `useListingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListingsQuery({
 *   variables: {
 *      brandId: // value for 'brandId'
 *      page: // value for 'page'
 *      perPage: // value for 'perPage'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useListingsQuery(baseOptions: Apollo.QueryHookOptions<ListingsQuery, ListingsQueryVariables> & ({ variables: ListingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListingsQuery, ListingsQueryVariables>(ListingsDocument, options);
      }
export function useListingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListingsQuery, ListingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListingsQuery, ListingsQueryVariables>(ListingsDocument, options);
        }
export function useListingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ListingsQuery, ListingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ListingsQuery, ListingsQueryVariables>(ListingsDocument, options);
        }
export type ListingsQueryHookResult = ReturnType<typeof useListingsQuery>;
export type ListingsLazyQueryHookResult = ReturnType<typeof useListingsLazyQuery>;
export type ListingsSuspenseQueryHookResult = ReturnType<typeof useListingsSuspenseQuery>;
export type ListingsQueryResult = Apollo.QueryResult<ListingsQuery, ListingsQueryVariables>;
export const OrdersDocument = gql`
    query orders($brandId: ID!, $page: Int, $perPage: Int, $search: OrderSearch) {
  orders(brandId: $brandId, page: $page, perPage: $perPage, search: $search) {
    orders {
      ...orderFragment
    }
    pagination {
      ...paginationFragment
    }
  }
}
    ${OrderFragmentFragmentDoc}
${PaginationFragmentFragmentDoc}`;

/**
 * __useOrdersQuery__
 *
 * To run a query within a React component, call `useOrdersQuery` and pass it any options that fit your needs.
 * When your component renders, `useOrdersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOrdersQuery({
 *   variables: {
 *      brandId: // value for 'brandId'
 *      page: // value for 'page'
 *      perPage: // value for 'perPage'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useOrdersQuery(baseOptions: Apollo.QueryHookOptions<OrdersQuery, OrdersQueryVariables> & ({ variables: OrdersQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OrdersQuery, OrdersQueryVariables>(OrdersDocument, options);
      }
export function useOrdersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OrdersQuery, OrdersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OrdersQuery, OrdersQueryVariables>(OrdersDocument, options);
        }
export function useOrdersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<OrdersQuery, OrdersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OrdersQuery, OrdersQueryVariables>(OrdersDocument, options);
        }
export type OrdersQueryHookResult = ReturnType<typeof useOrdersQuery>;
export type OrdersLazyQueryHookResult = ReturnType<typeof useOrdersLazyQuery>;
export type OrdersSuspenseQueryHookResult = ReturnType<typeof useOrdersSuspenseQuery>;
export type OrdersQueryResult = Apollo.QueryResult<OrdersQuery, OrdersQueryVariables>;
export const ProductDocument = gql`
    query product($brandId: ID!, $uuid: ID!) {
  product(uuid: $uuid) {
    ...productFragment
    productMaster {
      ...productMasterFragment
      sizes {
        ...sizeFragment
      }
      categories {
        ...categoryFragment
      }
    }
    images {
      ...imageFragment
    }
  }
  colors(brandId: $brandId) {
    ...colorFragment
  }
  sizes(brandId: $brandId) {
    ...sizeFragment
  }
  categories(brandId: $brandId) {
    ...categoryFragment
  }
}
    ${ProductFragmentFragmentDoc}
${ProductMasterFragmentFragmentDoc}
${SizeFragmentFragmentDoc}
${CategoryFragmentFragmentDoc}
${ImageFragmentFragmentDoc}
${ColorFragmentFragmentDoc}`;

/**
 * __useProductQuery__
 *
 * To run a query within a React component, call `useProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductQuery({
 *   variables: {
 *      brandId: // value for 'brandId'
 *      uuid: // value for 'uuid'
 *   },
 * });
 */
export function useProductQuery(baseOptions: Apollo.QueryHookOptions<ProductQuery, ProductQueryVariables> & ({ variables: ProductQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
      }
export function useProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductQuery, ProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
        }
export function useProductSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProductQuery, ProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
        }
export type ProductQueryHookResult = ReturnType<typeof useProductQuery>;
export type ProductLazyQueryHookResult = ReturnType<typeof useProductLazyQuery>;
export type ProductSuspenseQueryHookResult = ReturnType<typeof useProductSuspenseQuery>;
export type ProductQueryResult = Apollo.QueryResult<ProductQuery, ProductQueryVariables>;
export const ProductMasterDocument = gql`
    query productMaster($brandId: ID!, $code: String!) {
  productMaster(brandId: $brandId, code: $code) {
    ...productMasterFragment
  }
}
    ${ProductMasterFragmentFragmentDoc}`;

/**
 * __useProductMasterQuery__
 *
 * To run a query within a React component, call `useProductMasterQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductMasterQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductMasterQuery({
 *   variables: {
 *      brandId: // value for 'brandId'
 *      code: // value for 'code'
 *   },
 * });
 */
export function useProductMasterQuery(baseOptions: Apollo.QueryHookOptions<ProductMasterQuery, ProductMasterQueryVariables> & ({ variables: ProductMasterQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductMasterQuery, ProductMasterQueryVariables>(ProductMasterDocument, options);
      }
export function useProductMasterLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductMasterQuery, ProductMasterQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductMasterQuery, ProductMasterQueryVariables>(ProductMasterDocument, options);
        }
export function useProductMasterSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProductMasterQuery, ProductMasterQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductMasterQuery, ProductMasterQueryVariables>(ProductMasterDocument, options);
        }
export type ProductMasterQueryHookResult = ReturnType<typeof useProductMasterQuery>;
export type ProductMasterLazyQueryHookResult = ReturnType<typeof useProductMasterLazyQuery>;
export type ProductMasterSuspenseQueryHookResult = ReturnType<typeof useProductMasterSuspenseQuery>;
export type ProductMasterQueryResult = Apollo.QueryResult<ProductMasterQuery, ProductMasterQueryVariables>;
export const ProductsDocument = gql`
    query products($brandId: ID!, $page: Int, $perPage: Int, $search: ProductSearch) {
  products(brandId: $brandId, page: $page, perPage: $perPage, search: $search) {
    products {
      ...productFragment
      productMaster {
        ...productMasterFragment
        categories {
          ...categoryFragment
        }
      }
      color {
        ...colorFragment
      }
    }
    pagination {
      ...paginationFragment
    }
  }
}
    ${ProductFragmentFragmentDoc}
${ProductMasterFragmentFragmentDoc}
${CategoryFragmentFragmentDoc}
${ColorFragmentFragmentDoc}
${PaginationFragmentFragmentDoc}`;

/**
 * __useProductsQuery__
 *
 * To run a query within a React component, call `useProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductsQuery({
 *   variables: {
 *      brandId: // value for 'brandId'
 *      page: // value for 'page'
 *      perPage: // value for 'perPage'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useProductsQuery(baseOptions: Apollo.QueryHookOptions<ProductsQuery, ProductsQueryVariables> & ({ variables: ProductsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
      }
export function useProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
        }
export function useProductsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
        }
export type ProductsQueryHookResult = ReturnType<typeof useProductsQuery>;
export type ProductsLazyQueryHookResult = ReturnType<typeof useProductsLazyQuery>;
export type ProductsSuspenseQueryHookResult = ReturnType<typeof useProductsSuspenseQuery>;
export type ProductsQueryResult = Apollo.QueryResult<ProductsQuery, ProductsQueryVariables>;
export const CurrentUserDocument = gql`
    query currentUser {
  currentUser {
    ...userFragment
    organization {
      ...organizationFragment
      brands {
        ...brandFragment
      }
      sellers {
        ...sellerFragment
      }
    }
  }
}
    ${UserFragmentFragmentDoc}
${OrganizationFragmentFragmentDoc}
${BrandFragmentFragmentDoc}
${SellerFragmentFragmentDoc}`;

/**
 * __useCurrentUserQuery__
 *
 * To run a query within a React component, call `useCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrentUserQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrentUserQuery(baseOptions?: Apollo.QueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
      }
export function useCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
        }
export function useCurrentUserSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
        }
export type CurrentUserQueryHookResult = ReturnType<typeof useCurrentUserQuery>;
export type CurrentUserLazyQueryHookResult = ReturnType<typeof useCurrentUserLazyQuery>;
export type CurrentUserSuspenseQueryHookResult = ReturnType<typeof useCurrentUserSuspenseQuery>;
export type CurrentUserQueryResult = Apollo.QueryResult<CurrentUserQuery, CurrentUserQueryVariables>;
export const UserDocument = gql`
    query user($id: ID!) {
  user(id: $id) {
    ...userFragment
  }
}
    ${UserFragmentFragmentDoc}`;

/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserQuery(baseOptions: Apollo.QueryHookOptions<UserQuery, UserQueryVariables> & ({ variables: UserQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserQuery, UserQueryVariables>(UserDocument, options);
      }
export function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserQuery, UserQueryVariables>(UserDocument, options);
        }
export function useUserSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UserQuery, UserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserQuery, UserQueryVariables>(UserDocument, options);
        }
export type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export type UserSuspenseQueryHookResult = ReturnType<typeof useUserSuspenseQuery>;
export type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;